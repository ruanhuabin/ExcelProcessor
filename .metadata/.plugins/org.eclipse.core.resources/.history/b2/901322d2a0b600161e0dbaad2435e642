# encoding: utf-8
from Logger import MyLogger
import logging
import math
import re
import pprint
#import operator

logger = MyLogger("Lipid-Logger", logging.INFO).getLogger()
ms2Window = 0.2
topRTRange = 0.25

def makeTestData():
    dataBook = {}
    fileBook1 = {}
    fileBook2 = {}
    
    fileBook3 = {}
    
    
    fileBook1["LipidIon"] = ["ChE(18:3)+H", "ChE(20:5)+NH4", "ChE(20:5)+H", "ChE(22:4)+NH4", "ChE(20:5)+H"]
    fileBook1["Rt"] = ["10.1", "10.2", "10.3","10.4", "11.80"]
    fileBook1["TopRT"] = ["10.25", "10.42", "10.45", "10.88", "11.64"]
    fileBook1["Formula"] = ["fm1", "fm2", "fm2", "fm2", "fm2"]
    fileBook1["Grade"] = ["A", "A", "B", "B", "D"]
    
    fileBook2["LipidIon"] = ["NE(18:3)+H", "ChE(20:5)+NH4", "NE(20:5)+H", "ChE(22:4)+NH4", "ChE(20:5)+H"]
    fileBook2["Rt"] = ["10.1", "10.2", "10.3","10.4", "10.4"]
    fileBook2["TopRT"] = ["10.25", "10.42", "10.45", "10.92", "10.55"]
    fileBook2["Formula"] = ["fm1", "fm2", "fm2", "fm2", "fm2"]
    fileBook2["Grade"] = ["A", "D", "C", "D", "B"]
    
    
    fileBook3["LipidIon"] = ["TG(4:0/16:0/22:5)+NH4", "TG(4:0/22:5/16:0)+NH4", "DG(16:0/4:0/22:5)+NH4", "DG(4:0/16:0/22:5)+NH4", "TG(4:0/16:0/28:4)+NH4"]
    fileBook3["Rt"] = ["10.1", "10.2", "10.3","10.4", "10.4"]
    fileBook3["TopRT"] = ["10.25", "10.37", "10.41", "10.52", "10.50"]
    fileBook3["Formula"] = ["fm2", "fm2", "fm2", "fm2", "fm2"]
    fileBook3["Grade"] = ["A", "D", "C", "D", "B"]
    
    dataBook["f1"] = fileBook1;
    dataBook["f2"] = fileBook2;
    dataBook["f3"] = fileBook3;
    
    
    return dataBook        

#将样品数据组织成五元组的形式(lipidIons, Rts, TopRTs, diff, Formulas, Grades)        
def makeTuple(dataBook):
    logger.info("Start to make databook as tuple list")    
    lipidInfo = []    
    files = list(dataBook)
    for f in files:
        fileData = dataBook[f]
        lipidIons = fileData["LipidIon"]
        Rts = fileData["Rt"]
        TopRTs = fileData["TopRT"]
        Formulas = fileData["Formula"]
        Grades = fileData["Grade"]
        
        logger.info("lipidIons:" + str(lipidIons)) 
        logger.info("Rts:" + str(Rts))
        logger.info("TopRTs:" + str(TopRTs))
        logger.info("Formulas:" + str(Formulas))
        logger.info("Grades:" + str(Grades))
        logger.info("--------------------------------------------------------------")
        
        columnDataSize = len(lipidIons)
        for i in range(columnDataSize):
            diff = math.fabs(float(Rts[i]) - float(TopRTs[i]))
            li = (lipidIons[i], Rts[i], TopRTs[i], diff, Formulas[i], Grades[i])
            lipidInfo.append(li)
    
    #lipidInfo = sorted(lipidInfo,key=operator.itemgetter(3,0),reverse=False)            
    logger.info("End to make databook as tuple list")    
    return lipidInfo     

#在lipidInfo中删除RT和TopRT差值大于0.2的元组
def rm0dot2(lipidInfo):
    
    logger.info("Start to remove item that the gap between RT and TopRT is bigger than ms2Window(0.2)")
    newLipidInfo = []
    for item in lipidInfo:
        diff = item[3]
        if(diff <= ms2Window):
            newLipidInfo.append(item)
    
    logger.info("End to remove item that the gap between RT and TopRT is bigger than ms2Window(0.2)")
    
    return newLipidInfo


#计算每一种化合物在所有文件中的TopRT的平均值
def calTopRTAvg(lipidInfo):
    avgTable = {};
    topRTTable = {}
    for item in lipidInfo:
        lipidName = item[0]
        topRT = item[2]
        
        if(topRTTable.has_key(lipidName)):
            topRTTable[lipidName].append(float(topRT))
        else:
            topRTTable[lipidName] = [float(topRT)]


    logger.info("topRT Table = " + str(topRTTable))
    
    for(k, v) in topRTTable.iteritems():
        if(len(v) == 0):
            avgTable[k] = 0.0
        else:
            avgTable[k] = sum(v)/len(v)
        
    logger.info("avg Table = " + str(avgTable))
    return (avgTable, topRTTable)

#拿到所有相同formula对应的set(化合物),具有相同formula的化合物可以通过topRTTable这个dict来取得其所有的topRT值
def getFormulaMap(lipidInfo):
    
    logger.info("Start to get lipid names with same formula")
    f2c = {}
    
    
    
    for item in lipidInfo:
        formula = item[4]
        lipidName = item[0]
        #topRT = item[2]
        if(f2c.has_key(formula)):            
            f2c[formula].add(lipidName)            
        else:
            f2c[formula] = set([lipidName])
            
    
    logger.info("end to get lipid names with same formula")
    return f2c
               
#获取化合物括号部分数字对的个数。
def getGroupNum(compndName):
    
    parenthesesPart = re.search('\(.*\)', compndName).group();   
    #print("parenthesesPart = " + str(parenthesesPart))
    semicolon = re.findall(':', str(parenthesesPart))  
    
    #print("semicolon = " + str(semicolon))    
    
    return len(semicolon)
#提取符合条件2.1的(化合物,toprt)，同时将该化合物信息从候选的lipidInfo中剔除
def p2dot1(f2c, c2TopRTAvg, c2TopRT):
    
    
    logger.info("Start to process lipid info with only one group num")
    vldLipidInfo = []
    
    
    for (k, v) in f2c.iteritems():
        lipidNames = list(v)
        for n in lipidNames:
            grpNum = getGroupNum(n)
            if(grpNum > 1):
                continue
            
            #处理只有1组数字对的情况
            lipidAvg = c2TopRTAvg[n]
            topRTs = c2TopRT[n]
            
            #保存需要重新计算平均值的topRT值
            mergeValues = []
            #保存需要单独保存的topRT值
            unMergeValues = []
            for topRT in topRTs:
                diff = math.fabs(topRT - lipidAvg)
                
                if(diff <= topRTRange):
                    mergeValues.append(topRT)
                else:
                    unMergeValues.append(topRT)
            
            if(len(mergeValues) >= 1):
                newAvg = sum(mergeValues) / len(mergeValues)
                vldLipidInfo.append((n, newAvg))
            
            for value in unMergeValues:
                vldLipidInfo.append((n, value))
                    
                    
    logger.info("End to process lipid info with only one group num")                
    return vldLipidInfo        
        
#拿到化合物括号中的数字对等信息
def getInfoInPare(lipidName):
    parenthesesPart = re.search('\(.*\)', lipidName).group();
    parenthesesPart = str(parenthesesPart)
    parenthesesPart = parenthesesPart[1:len(parenthesesPart) - 1]    
    logger.info("parenthesesPart = " + parenthesesPart)    
    elems = re.split('\+|/', parenthesesPart)    
    logger.info("elems = " + str(elems))
    
    elems = sorted(elems)
    return elems   
#将DG，TG开头的化合物中间的数字部分重新按照升序排列，以便于发现相同的化合物
def reorderDGTG(c2TopRT):
    
    logger.info("Start to reorder the lipid-->toprts pair with the lipid name start with DG, TG")
    #newc2TopRT中，key保存以DG，TG开头，括号部分经过排序的化合物，value是化合物名称经过处理后是相同的化合物的所有的topRT值
    newc2TopRT = {}
    newc2TopRTAvg = {}
    for (k,v)in c2TopRT.iteritems():
        prefix = k[0:2]
        if(prefix != "DG" or prefix != "TG"):
            continue;
        
        topRTs = c2TopRT[k]
        elems = getInfoInPare(k)
        newPare = '+'.join(elems)
        newPare = "(" + newPare + ")"
        suffix = k[k.find(')') + 1:]
        newLipidName = prefix + newPare + suffix
        
        if(newc2TopRT.has_key(newLipidName)):
            for topRT in topRTs:
                newc2TopRT[newLipidName].append(topRT)
        else:            
                newc2TopRT[newLipidName] = topRTs
        
    
    for (k,v) in newc2TopRT:
        if(len(v) == 0):
            newc2TopRTAvg[k] = 0.0
        else:
            newc2TopRTAvg[k] = sum(v)/len(v)
            
    
    logger.info("End to reorder the lipid-->toprts pair with the lipid name start with DG, TG")
    return (newc2TopRTAvg, newc2TopRT)
        
            
        
                
def p2dot2(f2c, c2TopRTAvg, c2TopRT):
    
    for(k,v) in f2c:
        lipidNames = list(v)
        
        for n in lipidNames:
            prefix = n[0:2]
            #只处理DG或者TG开头的
            if(prefix != "DG" or prefix != "TG"):
                continue
            
            #开始处理TG或DG开头的化合物
            grps = getInfoInPare(n)
            grps = sorted(grps)
                                          

if __name__ == '__main__':
        
    #得到目录./lipddata下的所有文件的内容，以dict的形式组织，该dict的key是文件名，value是文件的内容，文件的内容又
    #以dict的形式进行组织，key是对应文件中的每1列的标题，value是该列对应的内容
    #dataBook = loadAllTextFile("./lipiddata", logger)
    dataBook = makeTestData()
    lipidInfo = makeTuple(dataBook)
    logger.info("Before removing item that the gap between RT and TopRT is bigger than ms2Window(0.2)")
    pprint.pprint(lipidInfo)
    logger.info("After removing item that the gap between RT and TopRT is bigger than ms2Window(0.2)")
    lipidInfo = rm0dot2(lipidInfo)
    
    (c2TopRTAvg, c2TopRT) = calTopRTAvg(lipidInfo)
    
    f2c = getFormulaMap(lipidInfo)
    logger.info("lipid name with same formula: " + str(f2c))
    
    lipidInfoIn2dot1 = p2dot1(f2c, c2TopRTAvg,c2TopRT)
    logger.info("lipidInfoIn2dot1: " + str(lipidInfoIn2dot1))
    
    (newc2TopRTAvg, newc2TopRT) = reorderDGTG(c2TopRTAvg)
    
    logger.info("newc2TopRT = " + str(newc2TopRT))
    logger.info("newc2TopRTAvg = " + str(newc2TopRTAvg))
    
    
    pass